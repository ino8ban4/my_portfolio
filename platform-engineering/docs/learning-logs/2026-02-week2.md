# 学習ログ: 2026年2月 Week2 (2/8-2/14)

## 📅 期間
2026年2月8日（土）〜 2月14日（金）

## 🎯 今週の目標
- [ ] Kubernetes概念学習
- [ ] minikube環境構築
- [ ] 実際にPodデプロイ

---

## 2/9（日）
**学習時間:** 1.5時間
**学習内容:**
- docker-composeにPostgreSQL追加
  - マルチコンテナ構成（アプリ + DB）
  - 環境変数でDB接続文字列管理
  - depends_on でコンテナ起動順序制御
  - volumesでデータ永続化
- Express APIからPostgreSQL接続実装
  - pg（node-postgres）ライブラリ使用
  - /db-test エンドポイント追加
  - 接続テスト成功
- .dockerignore作成
  - ビルドコンテキスト最適化
  - 不要ファイル除外（node_modules, .git, READMEなど）
  - イメージサイズ削減（200MB以下確認）
- ポート競合のトラブルシューティング
  - ローカルのPostgreSQL停止で解決

**学んだこと:**
- docker-composeでのマルチコンテナ管理
  - services間の依存関係（depends_on）
  - named volumesでのデータ永続化
  - 環境変数による設定の外部化
- .dockerignoreの重要性
  - ビルド時のみ効く（volumes マウントは対象外）
  - ビルドの度に参照される
  - キャッシュとは独立した仕組み
- コンテナベース開発の利点
  - 開発環境と本番環境の差異を最小化
  - チーム全員が同じDB環境を使える

**気づき・メモ:**
- ポート競合はよくあるトラブル
- DATABASE_URLで接続文字列を管理するのがベストプラクティス
- .dockerignoreとDockerfileのマルチステージビルドで二重に最適化

**参考資料:**
- Docker Compose公式ドキュメント: https://docs.docker.com/compose/
- node-postgres: https://node-postgres.com/
- PostgreSQL Docker Hub: https://hub.docker.com/_/postgres

**次回やること:**
- Issue #3: Kubernetes概念学習

---

## 2/11（水・祝）
**学習時間:** 1.5時間
**学習内容:**
- Kubernetes概念学習（記事読み込み）
  - Harmonic Society記事
  - SIOS記事
  - 各種K8s入門記事
- K8s基本概念の整理
  - コンテナオーケストレーションの必要性
  - クラウドネイティブ、マルチクラウド、マイクロサービスとの関係
  - docker-composeとの違い

**理解した主要概念:**

### K8sの3大機能
1. **自動スケーリング**
   - CPU使用率に応じてPod数を動的に増減
   - アクセス減少時はリソース節約

2. **セルフヒーリング**
   - ヘルスチェック → 自動再起動 → 自動置き換え
   - ノード障害時も他サーバにPod移動
   - 前提: 1 Pod = 1責務（最小構成）

3. **負荷分散（ロードバランサ）**
   - Serviceリソースが自動的にリクエスト分散

### K8sの管理単位
- **Pod**: 1つ以上のコンテナをまとめた最小実行単位（実行中のアプリのインスタンス）
- **Deployment**: アプリケーションのデプロイを宣言的に管理（設計図）
- **Service**: 複数Podへの統一的なアクセスポイント（固定の受け口）
- **Namespace**: プロジェクト・チーム・環境の論理的な区切り（フォルダのようなもの）

### DeploymentとPodの関係
```
Deployment（設計図）作成
  ↓ kubectl apply
K8sが自動的にReplicaSet作成
  ↓ 自動
Pod × replicas数 が生成
  ↓
実際にコンテナが動く
```

### docker-composeとの違い
- **Compose**: 個人開発・単一サーバに適している
- **K8s**: 複数サーバ管理、自動スケーリング、大規模システム向け

### 導入検討の判断基準
**重要な考え方:**
> 技術はあくまで手段であり目的ではない。課題ありきで検討する。

**導入を検討すべき状況例:**
- 数万の同時アクセス処理が必要
- マイクロサービスで多数のAPを連携
- 1日に何度もリリースする開発体制
- システム停止が大きな損失につながる

**学んだこと:**
- K8sの哲学: コンテナ（Pod）は小さく、単機能に
- Podは「スケーリングできる最大数」ではなく「実行中のアプリの実体」
- Serviceの役割: Podが頻繁に作り直されIPが変わるため、固定アクセスポイントとして機能
- Namespaceはクラスではなくフォルダのイメージ
- セルフヒーリングの前提: 最小構成のコンテナ（1 Pod = 1責務）
- プラットフォームエンジニアリングと同じ「課題ありき」の思考

**参考資料:**
- Harmonic Society: https://harmonic-society.co.jp/what-is-kubernetes-beginners-guide/
- SIOS: https://tech-lab.sios.jp/archives/29764
- Avinton: https://avinton.com/blog/2025/01/kubernetes-learning-guide/

---

## 2/14（金）
**学習時間:** 3時間
**学習内容:**
- Kubernetes実践（minikube環境構築〜アプリデプロイ）
  - minikube環境構築（Colima + Docker driver）
  - kubectl基本操作習得
  - nginxデプロイ（コマンドライン）
  - YAMLマニフェスト作成
    - nginx-deployment.yaml
    - nginx-service.yaml
    - express-deployment.yaml
    - express-service.yaml
  - 自作Express APIのK8sデプロイ成功
  - Service（NodePort）で外部公開
  - 複数Pod（レプリカ2個）で負荷分散確認

**実践した流れ:**

### minikube起動からnginxデプロイまで
1. **minikube起動**
```bash
   minikube start --driver=docker
   kubectl get nodes  # クラスタ確認
```

2. **nginxデプロイ（コマンドライン）**
```bash
   kubectl create deployment nginx --image=nginx
   kubectl get all  # リソース確認
```

3. **ポートフォワードでアクセス**
```bash
   kubectl port-forward pod/nginx-xxx 8080:80
   # ブラウザで http://localhost:8080 確認
```

### YAMLマニフェストでの管理
4. **既存リソース削除**
```bash
   kubectl delete deployment nginx
```

5. **YAMLファイル作成・適用**
   - Deployment: replicas=2, nginx:1.25-alpine
   - Service: NodePort (30080)
```bash
   kubectl apply -f nginx-deployment.yaml
   kubectl apply -f nginx-service.yaml
   minikube service nginx-service  # 動作確認
```

### Express APIのK8sデプロイ
6. **Dockerイメージ準備**
```bash
   docker build -t express-api:v1 .
   minikube image load express-api:v1
```

7. **YAMLファイル作成・デプロイ**
   - imagePullPolicy: Never（ローカルイメージ使用）
   - replicas: 2
   - Service: NodePort (30300)

8. **動作確認**
```bash
   minikube service express-api-service
   curl http://<IP>:30300/
   curl http://<IP>:30300/health
   # → APIレスポンス成功
```

**理解した重要概念:**

### K8sクラスタとリソースの関係
```
minikube（K8sクラスタ全体）
└── Node: minikube（control-plane）
    ├── Deployment（設計図）
    │   └── ReplicaSet（Pod生成マシン）
    │       └── Pod × N（実行中のアプリ）
    └── Service（アクセスポイント）
```

### DeploymentとPodの関係
- Deploymentは設計図、Podは実行中のインスタンス
- `kubectl create deployment` → K8sが自動でReplicaSet → Pod生成
- Podは「スケーリングできる最大数」ではなく「実行中のアプリの実体」

### Serviceの役割
- Podは頻繁に作り直されIPが変わる → 直接アクセス不可
- Serviceが固定のアクセスポイント（受け口）として機能
- 複数Podへ自動ルーティング（負荷分散）

### スケーリングと閾値設定
- デフォルトreplicas: 1
- `kubectl scale deployment <name> --replicas=N` で増減
- HPA（Horizontal Pod Autoscaler）で自動スケーリング
  - CPU/メモリ使用率
  - リクエスト数/秒
  - カスタムメトリクス
  - スケーリング速度制限（stabilizationWindow）

### Docker環境の分離
- ホストのDocker（Colima）≠ minikube内部のDocker
- `minikube image load` でイメージをminikube内部にコピー
- `--driver=docker` = minikubeをDockerコンテナで動かす（イメージ共有ではない）
- 本番環境ではDocker Hub/GCR等のレジストリ使用

### YAMLマニフェストのメリット
- Git管理可能（バージョン管理）
- 再現性（同じ環境を何度でも作れる）
- レビュー可能（チーム開発）
- Infrastructure as Code

### Colima環境での注意点
- `minikube service <name>` が正解
- `curl $(minikube ip):30080` は動かない（Colima VM内にminikubeがいるため）
- `minikube tunnel` や `kubectl port-forward` が代替手段

**学んだこと:**
- K8sの宣言的管理の威力（設計図を渡すだけでK8sが全自動）
- YAMLファイルによるInfrastructure as Codeの実践
- ローカル開発環境でもK8sの本質的な動作を体験できる
- プラットフォームエンジニアリングの「自動化」「セルフサービス」の具体例
- スケーリングは単なるPod数の増減だが、その背後に複雑な制御が可能

**気づき・メモ:**
- minikubeは学習・開発に最適（本番環境との違いを理解した上で）
- YAMLファイル管理の重要性（コマンドラインは一時的な確認用）
- imagePullPolicy: Never の指定が必須（ローカルイメージ使用時）
- Serviceの種類（ClusterIP, NodePort, LoadBalancer）の使い分けが重要
- 今後はチートシート作成が必要

**参考資料:**
- Kubernetes公式ドキュメント: https://kubernetes.io/docs/
- minikube公式ドキュメント: https://minikube.sigs.k8s.io/docs/

**次回やること:**
- ConfigMap/Secretの理解
- Helmの基礎学習
- CI/CDパイプライン構築準備

---

## 💡 今週の学び
（週末に振り返りを記入）

## 🚀 次週に向けて
（週末に記入）